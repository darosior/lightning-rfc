#! /usr/bin/python3
# This script verifies hashes from keys, using
# ECDSA over the SECP256k1 curve

# Released by Lisa Neigut under CC0:
# https://creativecommons.org/publicdomain/zero/1.0/

from secp256k1 import PrivateKey

def verify_sig(secret, hash_digest, sig_bytes):
    """
        Verify that the provided signature was in fact
        generated by the given private key for the
        given hash_digest

        inputs:
        - privkey: a hex-string private key scalar
        - hash_digest: a hex-string hash message
        - sig: a 64-byte array of concatenated r + s values of the signature to verify

        returns:
        - True if valid signature,
        - False otherwise
    """
    if len(sig_bytes) != 64:
        raise ValueError("Expected a 64-byte array for sig, got {} ({})".format(len(sig_bytes), sig_bytes.hex()))

    privkey = PrivateKey(bytes(bytearray.fromhex(secret)), raw=True)
    sig = privkey.ecdsa_deserialize_compact(sig_bytes)
    return privkey.pubkey.ecdsa_verify(bytes(bytearray.fromhex(hash_digest)), sig, raw=True)


def generate_sig(secret, hash_digest):
    """
        Given a secret (privkey) scalar and hash_digets,
        returns a valid signature (64-bytes compact)

        inputs:
        privkey: a hex-string private key scalar
        hash_digest: a hex-string hash message to sign

        returns: 64-byte compact ecdsa sig
    """
    privkey = PrivateKey(bytes(bytearray.fromhex(secret)), raw=True)
    sig = privkey.ecdsa_sign(bytes(bytearray.fromhex(hash_digest)), raw=True)
    return privkey.ecdsa_serialize_compact(sig)
